C51 COMPILER V9.54   KEY                                                                   10/14/2024 10:24:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN ..\OUTPUT\key.obj
COMPILER INVOKED BY: E:\Keil_C51\C51\BIN\C51.EXE ..\SOURCE\key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\SOURCE) DEBUG OBJECT
                    -EXTEND PRINT(..\LISTING\key.lst) TABS(2) OBJECT(..\OUTPUT\key.obj)

line level    source

   1          /*******************************************************
   2          file.name : key.c
   3          version : 1.1
   4          description : 存放了一些用于按键的功能函数
   5          *******************************************************/
   6          
   7          #include "key.h"
   8          #include "led.h"
   9          #include <reg51.h>
  10          #include "timer.h"
  11          
  12          // 定义按键的状态
  13          #define       KEY1_ON       0x1   //0001
  14          #define       KEY2_ON       0x2   //0010
  15          #define       KEY3_ON       0x4   //0100
  16          #define       KEY4_ON       0x8   //1000
  17          
  18          // 定义按键io口
  19          sbit key1 = P0^0;
  20          sbit key2 = P0^1;
  21          sbit key3 = P0^2;
  22          sbit key4 = P0^3;
  23          
  24          // 定义变量
  25          unsigned char key_state = 0x0;
  26          unsigned char mark = 0;
  27          
  28          // 扫描指定的io口电平，查看开关的开合
  29          // 输出的是一个四位二进制数，其对应的二进制数就是开关开合的状态
  30          // 从低位到高位是开关1到4
  31          // 按键的扫描有两个模式:
  32          // MODEL1为按钮模式，按下为1，松开为0
  33          // MODEL2为开关模式，按键切换1和0的状态
  34          // 可以使用WAITING_RELEASE来设置是否有松手等待,不使用就传入0
  35          unsigned char Key_State_Scan(unsigned char model,unsigned char wait_mod)
  36          {
  37   1        unsigned char key_state_1 = 0x0;
  38   1        if(model == MODEL1)   //模式1，使用局部变量
  39   1        {
  40   2          if(!key1 || !key2 || !key3 || !key4)  // 检测是否有按键被按下
  41   2          {
  42   3            if(mark == 0)
  43   3            {
  44   4                short_delay_5ms();    //消抖
  45   4                if(!key1)
  46   4                {
  47   5                  key_state_1 = key_state_1 + KEY1_ON;  //按键赋值
  48   5                }
  49   4                if(!key2)
  50   4                {
  51   5                  key_state_1 = key_state_1 + KEY2_ON;
  52   5                }
  53   4                if(!key3)
  54   4                {
C51 COMPILER V9.54   KEY                                                                   10/14/2024 10:24:19 PAGE 2   

  55   5                  key_state_1 = key_state_1 + KEY3_ON;
  56   5                }
  57   4                if(!key4)
  58   4                {
  59   5                  key_state_1 = key_state_1 + KEY4_ON;
  60   5                }
  61   4                mark = 1;
  62   4            }
  63   3          }
  64   2          else
  65   2          {
  66   3            mark = 0;
  67   3          }
  68   2          key_state = key_state_1;
  69   2        }
  70   1        
  71   1        else if(model == MODEL2)    //模式2，使用静态变量
  72   1        {
  73   2          if(!key1 || !key2 || !key3 || !key4)  // 检测是否有按键被按下
  74   2          {
  75   3            short_delay_5ms();    //消抖
  76   3            if(!key1)
  77   3            {
  78   4              key_state = key_state ^ (1 << 0);  //按键赋值，按位取反
  79   4            }
  80   3            if(!key2)
  81   3            {
  82   4              key_state = key_state ^ (1 << 1);
  83   4            }
  84   3            if(!key3)
  85   3            {
  86   4              key_state = key_state ^ (1 << 2);
  87   4            }
  88   3            if(!key4)
  89   3            {
  90   4              key_state = key_state ^ (1 << 3);
  91   4            }
  92   3          }
  93   2          if(wait_mod == WAITING_RELEASE)
  94   2            {
  95   3              while(!key1 || !key2 || !key3 || !key4);
  96   3            }    //松手等待
  97   2        }
  98   1      
  99   1        return key_state;
 100   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    140    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
