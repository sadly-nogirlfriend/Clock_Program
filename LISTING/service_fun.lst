C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SERVICE_FUN
OBJECT MODULE PLACED IN ..\OUTPUT\service_fun.obj
COMPILER INVOKED BY: E:\Keil_C51\C51\BIN\C51.EXE ..\SOURCE\service_fun.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\SOURCE) DEBU
                    -G OBJECTEXTEND PRINT(..\LISTING\service_fun.lst) TABS(2) OBJECT(..\OUTPUT\service_fun.obj)

line level    source

   1          /*******************************************************
   2          file.name : service_fun.c
   3          version : 1.1
   4          description : 存放了一些用于程序运行的功能函数
   5          *******************************************************/
   6          
   7          // 包含的头文件
   8          #include "service_fun.h"
   9          #include <reg51.h>
  10          #include "key.h"
  11          #include "led.h"
  12          
  13          // 宏定义
  14          #define       WINDOW1       2
  15          #define       WINDOW2       3
  16          #define       WINDOW3       4
  17          #define       STOPWATCH_WINDOW  5
  18          #define       CLOCK_MOD     6
  19          #define       STOPWATCH_MOD   7
  20          
  21          // 时间变量区
  22          unsigned int second = 0;
  23          unsigned int mins = 21;
  24          unsigned int hours = 11;
  25          unsigned int day = 14;
  26          unsigned int mounth = 10;
  27          unsigned int year = 2024;
  28          int min_time = 0; 
  29          unsigned int stopwatch_sec = 0;  // 秒表计数
  30          unsigned int stopwatch_10ms = 0;
  31          
  32          unsigned char window1_num[] = "0000";  // 用于计数，窗口1
  33          unsigned char window2_num[] = "0000";  // 用于计数，窗口2
  34          unsigned char window3_num[] = "0000";  // 用于计数，窗口3
  35          unsigned char stopwatch_window_num[] = "0000";  // 用于计数，秒表窗口
  36          
  37          // 标记变量区
  38          unsigned char windows = WINDOW1;       // 窗口标记，默认为窗口1
  39          unsigned char Mod = CLOCK_MOD;         // 模式标记，默认为时钟模式
  40          unsigned char stopwatch_state = 0;     // 秒表开关标记
  41          unsigned int blinked_mark = 0;         // 屏幕闪烁定时标记
  42          unsigned char blinked_screen_State = 1;// 屏幕闪烁状态标记
  43          // 该函数用于日历的进位计算
  44          void time_carry()
  45          {
  46   1        if(min_time == 1000)
  47   1        {
  48   2          mins++;
  49   2          min_time = 0;
  50   2        }
  51   1        if(mins == 60)   //60分钟进1小时
  52   1        {
  53   2          hours++;
  54   2          mins = 0;
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 2   

  55   2        }
  56   1        if(hours == 24)  //24小时进1天
  57   1        {
  58   2          day++;
  59   2          hours = 0;
  60   2        }
  61   1      
  62   1        // 年月日进位
  63   1          if((year%4 == 0)&&(year%100 != 0)||(year%400 == 0))   // 闰年
  64   1          {
  65   2              switch (mounth)
  66   2              {
  67   3              case 1:
  68   3              case 3:
  69   3              case 5:
  70   3              case 7:
  71   3              case 8:
  72   3              case 10:
  73   3              if(day > 31)
  74   3                  {
  75   4                      mounth++;
  76   4                      day = 1;
  77   4                  }
  78   3                  break;
  79   3              case 12:
  80   3                  if(day > 31)
  81   3                  {
  82   4                      year++;
  83   4                      mounth = 1;
  84   4                      day = 1;
  85   4                  }
  86   3                  break;
  87   3              case 2:
  88   3                  if(day > 29)
  89   3                  {
  90   4                      mounth++;
  91   4                      day = 1;
  92   4                  }
  93   3                  break;
  94   3              case 4:
  95   3              case 6:
  96   3              case 9:
  97   3              case 11:
  98   3                  if(day > 30)
  99   3                  {
 100   4                      mounth++;
 101   4                      day = 1;
 102   4                  }
 103   3                  break;
 104   3              default:
 105   3                  break;
 106   3              }
 107   2          }
 108   1          else
 109   1        {
 110   2              switch (mounth)
 111   2              {
 112   3              case 1:
 113   3              case 3:
 114   3              case 5:
 115   3              case 7:
 116   3              case 8:
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 3   

 117   3              case 10:
 118   3              if(day > 31)
 119   3                  {
 120   4                      mounth++;
 121   4                      day = 1;
 122   4                  }
 123   3                  break;
 124   3              case 12:
 125   3                  if(day > 31)
 126   3                  {
 127   4                      year++;
 128   4                      mounth = 1;
 129   4                      day = 1;
 130   4                  }
 131   3                  break;
 132   3              case 2:
 133   3                  if(day > 28)
 134   3                  {
 135   4                      mounth++;
 136   4                      day = 1;
 137   4                  }
 138   3                  break;
 139   3              case 4:
 140   3              case 6:
 141   3              case 9:
 142   3              case 11:
 143   3                  if(day > 30)
 144   3                  {
 145   4                      mounth++;
 146   4                      day = 1;
 147   4                  }
 148   3                  break;
 149   3              default:
 150   3                  break;
 151   3              }
 152   2        }
 153   1      }
 154          // 该函数用于时钟校正时的按键功能设置
 155          // void fixed_clock_function();
 156          // 该函数用于时钟校正时的屏幕显示
 157          void blinked_display_windows()
 158          {
 159   1          // 屏幕闪烁处理
 160   1          blinked_mark++;
 161   1          if(blinked_mark == 200)
 162   1          {
 163   2              blinked_screen_State = ~blinked_screen_State;
 164   2          }
 165   1      
 166   1          // 屏幕闪烁显示
 167   1          switch (windows)
 168   1          {
 169   2          case WINDOW1:
 170   2              if(blinked_screen_State)
 171   2              {
 172   3                  display_str_once(window1_num);
 173   3              }
 174   2              break;
 175   2          case WINDOW2:
 176   2              if(blinked_screen_State)
 177   2              {
 178   3                  display_str_once(window2_num);
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 4   

 179   3              }
 180   2              break;
 181   2          case WINDOW3:
 182   2              if(blinked_screen_State)
 183   2              {
 184   3                  display_str_once(window3_num);
 185   3              }
 186   2              break;
 187   2          
 188   2          default:
 189   2              break;
 190   2          }
 191   1      }
 192          
 193          // 该函数用于数字转字符串,将四位整数转化为字符串
 194          // 注意数字为无符号整数，一定要大于0
 195          void num2str(unsigned int num,unsigned char* str)
 196          {
 197   1        str[3] = num%10+'0';
 198   1        str[2] = (num/10)%10+'0';
 199   1        str[1] = (num/100)%10+'0';
 200   1        str[0] = (num/1000)%10+'0';
 201   1      }
 202          
 203          // 该函数用于显示对应窗口
 204          void display_windows()
 205          {
 206   1        switch (Mod)
 207   1        {
 208   2        case CLOCK_MOD:
 209   2          switch (windows)
 210   2          {
 211   3          case WINDOW1:
 212   3            display_str_once(window1_num);
 213   3            break;
 214   3          case WINDOW2:
 215   3            display_str_once(window2_num);
 216   3            break;
 217   3          case WINDOW3:
 218   3            display_str_once(window3_num);
 219   3            break;
 220   3          default:
 221   3            display_str_once("----");
 222   3            break;
 223   3          }
 224   2          break;
 225   2        case STOPWATCH_MOD:
 226   2          display_str_once(stopwatch_window_num);
 227   2          break;
 228   2        default:
 229   2          break;
 230   2        }
 231   1      }
 232          
 233          void stopwatch_function()
 234          {
 235   1          if(stopwatch_state)
 236   1          {
 237   2              TR1 = 1;
 238   2          }
 239   1          else
 240   1          {
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 5   

 241   2              TR1 = 0;
 242   2          }
 243   1      }
 244          
 245          void key_fucntions()
 246          {
 247   1          unsigned char key_state = 0x0;      // 用于储存按键状态
 248   1          key_state = Key_State_Scan(MODEL1);
 249   1        // 当模式为时钟模式的时候，按键1的作用是切换窗口，分别显示年月时分
 250   1        if(((key_state>>0) & 1 )&&(Mod == CLOCK_MOD))
 251   1        {
 252   2          windows++;
 253   2          if(windows == WINDOW3 + 1)
 254   2          {
 255   3            windows = WINDOW1;
 256   3          }
 257   2        }
 258   1        // 当模式为秒表模式的时候，按键1的作用是开始和停止秒表
 259   1        if(((key_state>>0) & 1 )&&(Mod == STOPWATCH_MOD))
 260   1        {
 261   2          stopwatch_state = ~stopwatch_state;
 262   2        }
 263   1          // 当按键2被按下的时候，清零秒表
 264   1          if((key_state>>1) & 1)
 265   1          {
 266   2              stopwatch_state = 0;
 267   2              // 关闭T1定时器
 268   2              TR1 = 0;
 269   2              // 标志位清零
 270   2              TF1 = 0;
 271   2              // 重置TL1,TH1
 272   2              TL1 = (65536 - 10000)%256;
 273   2              TH1 = (65536 - 10000)/256;
 274   2              // 归零秒表计数
 275   2              stopwatch_sec = 0;
 276   2              stopwatch_10ms = 0;
 277   2              stopwatch_window_num[0] = '0';
 278   2              stopwatch_window_num[1] = '0';
 279   2              stopwatch_window_num[2] = '0';
 280   2              stopwatch_window_num[3] = '0';
 281   2          }
 282   1          // 当按键3被按下的时候，切换当前模式
 283   1          if((key_state>>2) & 1)
 284   1        {
 285   2          Mod++;
 286   2          if(Mod == STOPWATCH_MOD+1)
 287   2          {
 288   3            Mod = CLOCK_MOD;
 289   3          }
 290   2        }
 291   1      }
 292          
 293          
 294          // 窗口分配：window1 用于时钟
 295          void clock() interrupt 1
 296          {
 297   1        // 标志位清零
 298   1        TF0 = 0;
 299   1        // min_time为60ms
 300   1        TL0 = (65536 - 60000)%256;
 301   1        TH0 = (65536 - 60000)/256;
 302   1        min_time++;
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 6   

 303   1        time_carry();  // 日历进位操作
 304   1        num2str(mins+hours*100,window1_num);
 305   1        num2str(day+mounth*100,window2_num);
 306   1        num2str(year,window3_num);
 307   1      }
 308          
 309          void stopwatch() interrupt 3
 310          {
 311   1          // 标志位清零
 312   1          TF1 = 0;
 313   1          // 定时10ms(一般秒表显示的最小单位就为10ms)
 314   1          TL1 = (65536 - 10000)%256;
 315   1          TH1 = (65536 - 10000)/256;
 316   1          stopwatch_10ms++;
 317   1          // 进位
 318   1          if(stopwatch_10ms == 100)
 319   1          {
 320   2              stopwatch_sec++;
 321   2              stopwatch_10ms = 0;
 322   2          }
 323   1          if(stopwatch_sec == 61)
 324   1          {
 325   2              stopwatch_sec = 0; // 设定最长秒表计时60s
 326   2          }
 327   1      
 328   1          /*********************************************************
 329   1           * 注意，因为两个中断重用了同一个函数，如果在其中一个中断函数执
 330   1           * 行期间，另一个中断打断了当前终端，那么重用的函数传入的参数将
 331   1           * 会被覆写，可能造成一定问题。在这里，我们使用OVERLAY进行解决，
 332   1           * 在配置文件中为该函数添加单独的内存空间，将两个中断函数排除在
 333   1           * 重叠分析之外，防止中断间的串扰。具体用法参考OVERLAY文档。
 334   1          *********************************************************/
 335   1          num2str(stopwatch_10ms+stopwatch_sec*100,stopwatch_window_num);
 336   1      }
 337          
 338          // 按下按键5进入中断
 339          void clock_fixed() interrupt 0
 340          {
 341   1          unsigned char fixed__state = 1;
 342   1          // 关闭中断开关，防止二次进入中断
 343   1          EX0 = 0;
 344   1          while(fixed__state)
 345   1          {
 346   2              // 屏幕闪烁显示
 347   2              blinked_display_windows();
 348   2              // 进行一次按键扫描
 349   2              // unsigned char fixed_key_state = Key_State_Scan(MODEL1);
 350   2              // 按键1切换时间窗口
 351   2              // 按键2切换位数
 352   2              // 按键3加、按键4减
 353   2          }
 354   1      }
 355          
 356          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1135    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44       6
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 20:50:49 PAGE 7   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
