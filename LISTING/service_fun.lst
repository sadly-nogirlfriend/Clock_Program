C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SERVICE_FUN
OBJECT MODULE PLACED IN ..\OUTPUT\service_fun.obj
COMPILER INVOKED BY: E:\Keil_C51\C51\BIN\C51.EXE ..\SOURCE\service_fun.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\SOURCE) DEBU
                    -G OBJECTEXTEND PRINT(..\LISTING\service_fun.lst) TABS(2) OBJECT(..\OUTPUT\service_fun.obj)

line level    source

   1          /*******************************************************
   2          file.name : service_fun.c
   3          version : 1.1
   4          description : 存放了一些用于程序运行的功能函数
   5          *******************************************************/
   6          
   7          // 包含的头文件
   8          #include "service_fun.h"
   9          #include <reg51.h>
  10          #include "key.h"
  11          #include "led.h"
  12          
  13          // 宏定义
  14          #define       WINDOW1       2
  15          #define       WINDOW2       3
  16          #define       WINDOW3       4
  17          #define       STOPWATCH_WINDOW  5
  18          #define       CLOCK_MOD     6
  19          #define       STOPWATCH_MOD   7
  20          
  21          // 时间变量区
  22          unsigned int second = 0;
  23          unsigned int mins = 21;
  24          unsigned int hours = 11;
  25          unsigned int day = 14;
  26          unsigned int mounth = 10;
  27          unsigned int year = 2024;
  28          int min_time = 0; 
  29          unsigned int stopwatch_sec = 0;  // 秒表计数
  30          unsigned int stopwatch_10ms = 0;
  31          
  32          unsigned char window1_num[] = "0000";  // 用于计数，窗口1
  33          unsigned char window2_num[] = "0000";  // 用于计数，窗口2
  34          unsigned char window3_num[] = "0000";  // 用于计数，窗口3
  35          unsigned char stopwatch_window_num[] = "0000";  // 用于计数，秒表窗口
  36          
  37          // 标记变量区
  38          unsigned char windows = WINDOW1;       // 窗口标记，默认为窗口1
  39          unsigned char Mod = CLOCK_MOD;         // 模式标记，默认为时钟模式
  40          unsigned char stopwatch_state = 0;     // 秒表开关标记
  41          // 该函数用于日历的进位计算
  42          void time_carry()
  43          {
  44   1        if(min_time == 1000)
  45   1        {
  46   2          mins++;
  47   2          min_time = 0;
  48   2        }
  49   1        if(mins == 60)   //60分钟进1小时
  50   1        {
  51   2          hours++;
  52   2          mins = 0;
  53   2        }
  54   1        if(hours == 24)  //24小时进1天
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 2   

  55   1        {
  56   2          day++;
  57   2          hours = 0;
  58   2        }
  59   1      
  60   1        // 年月日进位
  61   1          if((year%4 == 0)&&(year%100 != 0)||(year%400 == 0))   // 闰年
  62   1          {
  63   2              switch (mounth)
  64   2              {
  65   3              case 1:
  66   3              case 3:
  67   3              case 5:
  68   3              case 7:
  69   3              case 8:
  70   3              case 10:
  71   3              if(day > 31)
  72   3                  {
  73   4                      mounth++;
  74   4                      day = 1;
  75   4                  }
  76   3                  break;
  77   3              case 12:
  78   3                  if(day > 31)
  79   3                  {
  80   4                      year++;
  81   4                      mounth = 1;
  82   4                      day = 1;
  83   4                  }
  84   3                  break;
  85   3              case 2:
  86   3                  if(day > 29)
  87   3                  {
  88   4                      mounth++;
  89   4                      day = 1;
  90   4                  }
  91   3                  break;
  92   3              case 4:
  93   3              case 6:
  94   3              case 9:
  95   3              case 11:
  96   3                  if(day > 30)
  97   3                  {
  98   4                      mounth++;
  99   4                      day = 1;
 100   4                  }
 101   3                  break;
 102   3              default:
 103   3                  break;
 104   3              }
 105   2          }
 106   1          else
 107   1        {
 108   2              switch (mounth)
 109   2              {
 110   3              case 1:
 111   3              case 3:
 112   3              case 5:
 113   3              case 7:
 114   3              case 8:
 115   3              case 10:
 116   3              if(day > 31)
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 3   

 117   3                  {
 118   4                      mounth++;
 119   4                      day = 1;
 120   4                  }
 121   3                  break;
 122   3              case 12:
 123   3                  if(day > 31)
 124   3                  {
 125   4                      year++;
 126   4                      mounth = 1;
 127   4                      day = 1;
 128   4                  }
 129   3                  break;
 130   3              case 2:
 131   3                  if(day > 28)
 132   3                  {
 133   4                      mounth++;
 134   4                      day = 1;
 135   4                  }
 136   3                  break;
 137   3              case 4:
 138   3              case 6:
 139   3              case 9:
 140   3              case 11:
 141   3                  if(day > 30)
 142   3                  {
 143   4                      mounth++;
 144   4                      day = 1;
 145   4                  }
 146   3                  break;
 147   3              default:
 148   3                  break;
 149   3              }
 150   2        }
 151   1      }
 152          
 153          // 该函数用于数字转字符串,将四位整数转化为字符串
 154          // 注意数字为无符号整数，一定要大于0
 155          void num2str(unsigned int num,unsigned char* str)
 156          {
 157   1        str[3] = num%10+'0';
 158   1        str[2] = (num/10)%10+'0';
 159   1        str[1] = (num/100)%10+'0';
 160   1        str[0] = (num/1000)%10+'0';
 161   1      }
 162          
 163          // 该函数用于显示对应窗口
 164          void display_windows()
 165          {
 166   1        switch (Mod)
 167   1        {
 168   2        case CLOCK_MOD:
 169   2          switch (windows)
 170   2          {
 171   3          case WINDOW1:
 172   3            display_str_once(window1_num);
 173   3            break;
 174   3          case WINDOW2:
 175   3            display_str_once(window2_num);
 176   3            break;
 177   3          case WINDOW3:
 178   3            display_str_once(window3_num);
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 4   

 179   3            break;
 180   3          default:
 181   3            display_str_once("----");
 182   3            break;
 183   3          }
 184   2          break;
 185   2        case STOPWATCH_MOD:
 186   2          display_str_once(stopwatch_window_num);
 187   2          break;
 188   2        default:
 189   2          break;
 190   2        }
 191   1      }
 192          
 193          void stopwatch_function()
 194          {
 195   1          if(stopwatch_state)
 196   1          {
 197   2              TR1 = 1;
 198   2          }
 199   1          else
 200   1          {
 201   2              TR1 = 0;
 202   2          }
 203   1      }
 204          
 205          void key_fucntions()
 206          {
 207   1          unsigned char key_state = 0x0;      // 用于储存按键状态
 208   1          key_state = Key_State_Scan(MODEL1);
 209   1        // 当模式为时钟模式的时候，按键1的作用是切换窗口，分别显示年月时分
 210   1        if(((key_state>>0) & 1 )&&(Mod == CLOCK_MOD))
 211   1        {
 212   2          windows++;
 213   2          if(windows == WINDOW3 + 1)
 214   2          {
 215   3            windows = WINDOW1;
 216   3          }
 217   2        }
 218   1        // 当模式为秒表模式的时候，按键1的作用是开始和停止秒表
 219   1        if(((key_state>>0) & 1 )&&(Mod == STOPWATCH_MOD))
 220   1        {
 221   2          stopwatch_state = ~stopwatch_state;
 222   2        }
 223   1          // 当按键2被按下的时候，清零秒表
 224   1          if((key_state>>1) & 1)
 225   1          {
 226   2              stopwatch_state = 0;
 227   2              // 关闭T1定时器
 228   2              TR1 = 0;
 229   2              // 标志位清零
 230   2              TF1 = 0;
 231   2              // 重置TL1,TH1
 232   2              TL1 = (65536 - 10000)%256;
 233   2              TH1 = (65536 - 10000)/256;
 234   2              // 归零秒表计数
 235   2              stopwatch_sec = 0;
 236   2              stopwatch_10ms = 0;
 237   2              stopwatch_window_num[0] = '0';
 238   2              stopwatch_window_num[1] = '0';
 239   2              stopwatch_window_num[2] = '0';
 240   2              stopwatch_window_num[3] = '0';
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 5   

 241   2          }
 242   1          // 当按键3被按下的时候，切换当前模式
 243   1          if((key_state>>2) & 1)
 244   1        {
 245   2          Mod++;
 246   2          if(Mod == STOPWATCH_MOD+1)
 247   2          {
 248   3            Mod = CLOCK_MOD;
 249   3          }
 250   2        }
 251   1      }
 252          
 253          
 254          // 窗口分配：window1 用于时钟
 255          void clock() interrupt 1
 256          {
 257   1        // 标志位清零
 258   1        TF0 = 0;
 259   1        // min_time为60ms
 260   1        TL0 = (65536 - 60000)%256;
 261   1        TH0 = (65536 - 60000)/256;
 262   1        min_time++;
 263   1        time_carry();  // 日历进位操作
 264   1        num2str(mins+hours*100,window1_num);
 265   1        num2str(day+mounth*100,window2_num);
 266   1        num2str(year,window3_num);
 267   1      }
 268          
 269          void stopwatch() interrupt 3
 270          {
 271   1          // 标志位清零
 272   1          TF1 = 0;
 273   1          // 定时10ms(一般秒表显示的最小单位就为10ms)
 274   1          TL1 = (65536 - 10000)%256;
 275   1          TH1 = (65536 - 10000)/256;
 276   1          stopwatch_10ms++;
 277   1          // 进位
 278   1          if(stopwatch_10ms == 100)
 279   1          {
 280   2              stopwatch_sec++;
 281   2              stopwatch_10ms = 0;
 282   2          }
 283   1          if(stopwatch_sec == 61)
 284   1          {
 285   2              stopwatch_sec = 0; // 设定最长秒表计时60s
 286   2          }
 287   1      
 288   1          /*********************************************************
 289   1           * 注意，因为两个中断重用了同一个函数，如果在其中一个中断函数执
 290   1           * 行期间，另一个中断打断了当前终端，那么重用的函数传入的参数将
 291   1           * 会被覆写，可能造成一定问题。在这里，我们使用OVERLAY进行解决，
 292   1           * 在配置文件中为该函数添加单独的内存空间，将两个中断函数排除在
 293   1           * 重叠分析之外，防止中断间的串扰。具体用法参考OVERLAY文档。
 294   1          *********************************************************/
 295   1          num2str(stopwatch_10ms+stopwatch_sec*100,stopwatch_window_num);
 296   1      }
 297          
 298          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    997    ----
C51 COMPILER V9.54   SERVICE_FUN                                                           10/15/2024 00:55:22 PAGE 6   

   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     41       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
